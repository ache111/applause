<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>ImportManager</title>
<meta name="description" content="">
<meta name="author" content="Jnario">

<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<link rel="stylesheet" href="../../../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../../../css/custom.css">
<link rel="stylesheet" href="../../../../../../css/prettify.css">
<script type="text/javascript" src="../../../../../../js/prettify.js"></script>
<script type="text/javascript" src="../../../../../../js/lang-jnario.js"></script>
<script type="text/javascript" src="../../../../../../js/jquery.js"></script>
<script type="text/javascript" src="../../../../../../js/bootstrap-tab.js"></script>
</head>

<body onload="prettyPrint()">
	<div class="container">
		<div class="tabbable">
			<div class="content">
				<div class="page-header notrun">
					<h1>ImportManager</h1>
					  <ul class="nav nav-tabs pull-right">
					    <li class="active"><a href="#spec" data-toggle="tab">Spec</a></li>
						<li><a href="#source" data-toggle="tab">Source</a></li>
					  </ul>
				</div>
				<div class="row">
					<div class="span12">
						  <div class="tab-content">
							  	<div class="tab-pane active" id="spec">
<p>The class based import manager is intended to be used with languages like <strong>Objective-C</strong> that do not support namespaces or packages.</p>
<h3 class="exampleGroup notrun"  id="Initialization">Initialization</h3>
<ul><li><p id="Initially_the_import_manager_is_empty" class="example notrun"><strong>Initially, the import manager is empty.</strong></p>
<pre class="prettyprint lang-spec linenums">
subject.empty should be true</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Adding_elements">Adding elements</h3>
<ul><li><p id="After_adding_an_element_the_import_manager_is_not_empty_any_more" class="example notrun"><strong>After adding an element, the import manager is not empty any more.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  entity Baz {
  }
''')
var baz = model.elements.head as Entity

subject.add(baz)
subject.empty should be false
subject.imports.size should be 1</pre>
</li><li><p id="Adding_the_same_element_multiple_times_only_yields_one_import" class="example notrun"><strong>Adding the same element multiple times only yields one import</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  entity Baz {
  }
''')
var baz = model.elements.head as Entity

subject.add(baz)
subject.add(baz)
subject.empty should be false
subject.imports.size should be 1</pre>
</li><li><p id="Adding_two_different_elements_yields_two_imports" class="example notrun"><strong>Adding two different elements yields two imports</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  entity Baz {
  }
  entity Boo {
  }
''')
var baz = model.elements.filter(typeof(Entity)).findFirst[name == &quot;Baz&quot;]
var boo= model.elements.filter(typeof(Entity)).findFirst[name == &quot;Boo&quot;]

subject.add(baz)
subject.add(boo)
subject.imports.size should be 2</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Types">Types</h3>
<ul><li><p id="Primitive_types_must_not_be_imported" class="example notrun"><strong>Primitive types must not be imported.</strong></p>
<p>Primitive types are types that are built in to the host language, such as <code>int</code> or <code>long</code> in Java.</p><p>We do not want to import them, as this</p>
<ul>
  <li>unneccesary and</li>
  <li>illegal in most cases.</li>
</ul>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.add(zapType)
subject.empty should be true</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Type_Mapping">Type Mapping</h3>
<p>Types can be mapped. This is needed in order to be able to use a common type system in the DSL while being able to use platform-specific types in the code generators for the individual platform.</p>
<ul><li><p id="Adding_a_primitive_type_must_not_yield_an_import_even_if_the_type_is_mapped" class="example notrun"><strong>Adding a primitive type must not yield an import, even if the type is mapped.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.add(zapType)
subject.empty should be true</pre>
</li><li><p id="However_serializing_a_primitive_type_must_yield_the_mapped_name_and_NO_import" class="example notrun"><strong>However, serializing a primitive type must yield the mapped name [and NO import].</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.serialize(zapType) should be 'zap'
subject.empty should be true</pre>
</li><li><p id="Mapping_a_regular_type_should_yield_the_mapped_type_name_as_an_import" class="example notrun"><strong>Mapping a regular type should yield the mapped type name as an import.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Bar
  platform ClassBased {
    typemapping Bar -&gt; BarClass
  }
''')

val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
subject.add(barType)
subject.imports.head should be 'BarClass'</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Serialization">Serialization</h3>
<p>Sometime we need to add a type to the import manager and use the type name at the same time. This process is called <em>serialization</em>.</p>
<ul><li><p id="Serializing_a_primitive_type_yields_its_mapped_name" class="example notrun"><strong>Serializing a primitive type yields its mapped name</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.serialize(zapType) should be 'zap'</pre>
</li><li><p id="Serializing_a_mapped_type_yields_its_mapped_name" class="example notrun"><strong>Serializing a mapped type yields its mapped name</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Foo
  platform ClassBased {
    typemapping Foo -&gt; FooClass
  }
''')

val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
subject.serialize(fooType) should be 'FooClass'</pre>
</li><li><p id="Serializing_an_unmapped_type_yields_its_regular_name" class="example notrun"><strong>Serializing an unmapped type yields its regular name</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Bar
''')

val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
subject.serialize(barType) should be 'Bar'</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Scope">Scope</h3>
<ul><li><p id="A_type_must_not_import_itself_Only_external_types_need_to_be_imported" class="example notrun"><strong>A type must not import itself. Only external types need to be imported.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  entity Foo { }
  entity Bar extends Foo {}
''')
val foo = model.elements.filter(typeof(Entity)).findFirst[name == 'Foo']
val bar = model.elements.filter(typeof(Entity)).findFirst[name == 'Bar']

val importManager = importManagerFactory.create(bar)

importManager.add(bar)
importManager.imports.size should be 0
importManager.serialize(bar) should be 'Bar'

importManager.serialize(foo) should be 'Foo'
importManager.imports.size should be 1</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Well_known_classes">Well-known classes</h3>
<p>Well-known classes are classes that are part of the runtime and do not need to be imported, or that are part of the runtime and need to be imported using a specific, predefined import.</p>
<ul><li><p id="Well_known_classes_can_register_a_specific_import" class="example notrun"><strong>Well-known classes can register a specific import</strong></p>
<p>Well-known classes can register a specific import. This makes sense for languages that support having more than one class inside a particular source file. In this case, the name of the import cannot be derived directly from the name of the class to be imported. Instead, we need to register an import for each of those classes.</p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Hubba
  datatype Chuppa
  platform ClassBased {
    typemapping Hubba -&gt; HubbaClass
    typemapping Chuppa -&gt; ChuppaClass
  }
''')
val hubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Hubba']
subject.serialize(hubba) should be 'HubbaClass'
subject.imports.head should be 'BaseClasses/ChewingGums'</pre>
</li><li><p id="Several_well_known_classes_can_register_the_same_specific_import" class="example notrun"><strong>Several well-known classes can register the same specific import</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Hubba
  datatype Chuppa
  datatype Bubba
  platform ClassBased {
    typemapping Hubba -&gt; HubbaClass
    typemapping Chuppa -&gt; ChuppaClass
    typemapping Bubba -&gt; BubbaClass
  }
''')
val hubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Hubba']
val bubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Bubba']
subject.serialize(hubba) should be 'HubbaClass'
subject.imports.head should be 'BaseClasses/ChewingGums'
subject.serialize(bubba) should be 'BubbaClass'
subject.imports.head should be 'BaseClasses/ChewingGums'</pre>
</li><li><p id="Well_known_classes_must_only_be_imported_if_they_register_an_import" class="example notrun"><strong>Well-known classes must only be imported if they register an import</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Hubba
  datatype Chuppa
  platform ClassBased {
    typemapping Hubba -&gt; HubbaClass
    typemapping Chuppa -&gt; ChuppaClass
  }
  entity Bar {
    Hubba bubba
    Chuppa chups
  }
''')

val bar = model.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
val importManager = importManagerFactory.create(bar)

val chups = bar.attributes.findFirst[name == 'chups']
importManager.serialize(chups.type) should be 'ChuppaClass'
importManager.imports.size should be 0

val hubba = bar.attributes.findFirst[name == 'bubba']
importManager.serialize(hubba.type) should be 'HubbaClass'
importManager.imports.size should be 1</pre>
</li></ul>
							</div>
						    <div class="tab-pane" id="source">
						    	<h3>ImportManager.spec</h3>
						    	<p>
<pre class="prettyprint lang-spec linenums">
package org.applause.lang.base.importmanager.classbased

import com.google.inject.Inject
import org.applause.lang.applauseDsl.DataType
import org.applause.lang.applauseDsl.Entity
import org.applause.lang.applauseDsl.Model
import org.applause.lang.applauseDsl.NamespaceDeclaration
import org.applause.lang.base.ImportManager
import org.applause.lang.base.ImportManagerFactory
import org.eclipse.xtext.junit4.util.ParseHelper
import org.jnario.runner.CreateWith

import static extension org.jnario.lib.Should.*

/**
 * The class based import manager is intended to be used with languages like **Objective-C** that do not 
 * support namespaces or packages.
 */
@CreateWith(typeof(ClassBasedSpecCreator))
describe ImportManager {
  
  @Inject ParseHelper&lt;Model&gt; parseHelper
  
  context &quot;Initialization&quot; {
    fact &quot;Initially, the import manager is empty.&quot; {
      subject.empty should be true 
    }
  }
  
  context &quot;Adding elements&quot; {
    fact &quot;After adding an element, the import manager is not empty any more.&quot; {
      val model = parseHelper.parse('''
        entity Baz {
        }
      ''')
      var baz = model.elements.head as Entity
      
      subject.add(baz)
      subject.empty should be false
      subject.imports.size should be 1
    }
    
    fact &quot;Adding the same element multiple times only yields one import&quot; {
      val model = parseHelper.parse('''
        entity Baz {
        }
      ''')
      var baz = model.elements.head as Entity
      
      subject.add(baz)
      subject.add(baz)
      subject.empty should be false
      subject.imports.size should be 1
    }
    
    // TODO this is namespace-related, remove it!
    def allNamespaces(Model model) {
      model.eAllContents.filter(typeof(NamespaceDeclaration))
    }
    
    fact &quot;Adding two different elements yields two imports&quot; {
      val model = parseHelper.parse('''
        entity Baz {
        }
        entity Boo {
        }
      ''')
      var baz = model.elements.filter(typeof(Entity)).findFirst[name == &quot;Baz&quot;]
      var boo= model.elements.filter(typeof(Entity)).findFirst[name == &quot;Boo&quot;]
      
      subject.add(baz)
      subject.add(boo)
      subject.imports.size should be 2
    }
    
  }
  
  context &quot;Types&quot; {
    /**
     * Primitive types are types that are built in to the host language, such as `int` or `long` 
     * in Java. 
     * 
     * We do not want to import them, as this
     *  
     * - unneccesary and 
     * - illegal in most cases.
     * 
     */
    fact &quot;Primitive types must not be imported.&quot; {
      val model = parseHelper.parse('''
        datatype Zap
        platform ClassBased {
          typemapping Zap -&gt; zap primitive
        }
      ''')
      
      val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
      subject.add(zapType)
      subject.empty should be true
    }
    
//    pending fact &quot;WHat's this?&quot; {
//      val model = parseHelper.parse('''
//        datatype Foo
//        platform ClassBased {
//          typemapping Foo -&gt; Foo (foo.base)
//        }
//      ''')
//    }
    
  }
  
  /**
   * Types can be mapped. This is needed in order to be able to use a common type system in the DSL
   * while being able to use platform-specific types in the code generators for the individual platform.
   */
  context &quot;Type Mapping&quot; {
    
    fact &quot;Adding a primitive type must not yield an import, even if the type is mapped.&quot; {
      val model = parseHelper.parse('''
        datatype Zap
        platform ClassBased {
          typemapping Zap -&gt; zap primitive
        }
      ''')
      
      val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
      subject.add(zapType)
      subject.empty should be true
    }
    
    fact &quot;However, serializing a primitive type must yield the mapped name (and NO import).&quot; {
      val model = parseHelper.parse('''
        datatype Zap
        platform ClassBased {
          typemapping Zap -&gt; zap primitive
        }
      ''')
      
      val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
      subject.serialize(zapType) should be 'zap'
      subject.empty should be true
    }
    
    fact &quot;Mapping a regular type should yield the mapped type name as an import.&quot; {
      val model = parseHelper.parse('''
        datatype Bar
        platform ClassBased {
          typemapping Bar -&gt; BarClass
        }
      ''')
      
      val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
      subject.add(barType)
      subject.imports.head should be 'BarClass'
    }
    
  }

  /**
   * Sometime we need to add a type to the import manager and use the type name at the same time. 
   * This process is called _serialization_.
   */
  context &quot;Serialization&quot; {
    fact &quot;Serializing a primitive type yields its mapped name&quot; {
      val model = parseHelper.parse('''
        datatype Zap
        platform ClassBased {
          typemapping Zap -&gt; zap primitive
        }
      ''')
      
      val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
      subject.serialize(zapType) should be 'zap'
    }
    
    fact &quot;Serializing a mapped type yields its mapped name&quot; {
      val model = parseHelper.parse('''
        datatype Foo
        platform ClassBased {
          typemapping Foo -&gt; FooClass
        }
      ''')
      
      val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
      subject.serialize(fooType) should be 'FooClass'
    }
    
    fact &quot;Serializing an unmapped type yields its regular name&quot; {
      val model = parseHelper.parse('''
        datatype Bar
      ''')
      
      val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
      subject.serialize(barType) should be 'Bar'
    }
  } 

  context &quot;Scope&quot; {
    
    @Inject ImportManagerFactory importManagerFactory
    
    fact &quot;A type must not import itself. Only external types need to be imported.&quot; {
      val model = parseHelper.parse('''
        entity Foo { }
        entity Bar extends Foo {}
      ''')
      val foo = model.elements.filter(typeof(Entity)).findFirst[name == 'Foo']
      val bar = model.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
      
      val importManager = importManagerFactory.create(bar)
      
      importManager.add(bar)
      importManager.imports.size should be 0
      importManager.serialize(bar) should be 'Bar'
      
      importManager.serialize(foo) should be 'Foo'
      importManager.imports.size should be 1
    }
    
  }
  
  /**
   * Well-known classes are classes that are part of the runtime and do not need to be imported, or that 
   * are part of the runtime and need to be imported using a specific, predefined import.
   */
  context &quot;Well-known classes&quot; {

    @Inject ImportManagerFactory importManagerFactory
    
    /**
     * Well-known classes can register a specific import. This makes sense for languages that support
     * having more than one class inside a particular source file. In this case, the name of the import
     * cannot be derived directly from the name of the class to be imported. Instead, we need to register
     * an import for each of those classes.
     */
    fact &quot;Well-known classes can register a specific import&quot; {
      val model = parseHelper.parse('''
        datatype Hubba
        datatype Chuppa
        platform ClassBased {
          typemapping Hubba -&gt; HubbaClass
          typemapping Chuppa -&gt; ChuppaClass
        }
      ''')
      val hubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Hubba']
      subject.serialize(hubba) should be 'HubbaClass'
      subject.imports.head should be 'BaseClasses/ChewingGums'
    }
    
    fact &quot;Several well-known classes can register the same specific import&quot; {
      val model = parseHelper.parse('''
        datatype Hubba
        datatype Chuppa
        datatype Bubba
        platform ClassBased {
          typemapping Hubba -&gt; HubbaClass
          typemapping Chuppa -&gt; ChuppaClass
          typemapping Bubba -&gt; BubbaClass
        }
      ''')
      val hubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Hubba']
      val bubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Bubba']
      subject.serialize(hubba) should be 'HubbaClass'
      subject.imports.head should be 'BaseClasses/ChewingGums'
      subject.serialize(bubba) should be 'BubbaClass'
      subject.imports.head should be 'BaseClasses/ChewingGums'
    }
    
    fact &quot;Well-known classes must only be imported if they register an import&quot; {
      val model = parseHelper.parse('''
        datatype Hubba
        datatype Chuppa
        platform ClassBased {
          typemapping Hubba -&gt; HubbaClass
          typemapping Chuppa -&gt; ChuppaClass
        }
        entity Bar {
          Hubba bubba
          Chuppa chups
        }
      ''')
      
      val bar = model.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
      val importManager = importManagerFactory.create(bar)
      
      val chups = bar.attributes.findFirst[name == 'chups']
      importManager.serialize(chups.type) should be 'ChuppaClass'
      importManager.imports.size should be 0

      val hubba = bar.attributes.findFirst[name == 'bubba']
      importManager.serialize(hubba.type) should be 'HubbaClass'
      importManager.imports.size should be 1
    }
    
  }

}
</pre>
						    </p></div>
						  </div>
					</div> 
				</div> <!-- /row -->
			</div> <!-- /content -->
		</div> <!-- /tabbable -->
		<footer>
			<p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>
	</div> <!-- /container -->

</body>
</html>
