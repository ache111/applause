<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>ImportManager</title>
<meta name="description" content="">
<meta name="author" content="Jnario">

<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<link rel="stylesheet" href="../../../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../../../css/custom.css">
<link rel="stylesheet" href="../../../../../../css/prettify.css">
<script type="text/javascript" src="../../../../../../js/prettify.js"></script>
<script type="text/javascript" src="../../../../../../js/lang-jnario.js"></script>
<script type="text/javascript" src="../../../../../../js/jquery.js"></script>
<script type="text/javascript" src="../../../../../../js/bootstrap-tab.js"></script>
</head>

<body onload="prettyPrint()">
	<div class="container">
		<div class="tabbable">
			<div class="content">
				<div class="page-header pending">
					<h1>ImportManager</h1>
					  <ul class="nav nav-tabs pull-right">
					    <li class="active"><a href="#spec" data-toggle="tab">Spec</a></li>
						<li><a href="#source" data-toggle="tab">Source</a></li>
					  </ul>
				</div>
				<div class="row">
					<div class="span12">
						  <div class="tab-content">
							  	<div class="tab-pane active" id="spec">
<h3 class="exampleGroup notrun"  id="Initialization">Initialization</h3>
<ul><li><p id="Initially_the_import_manager_is_empty" class="example notrun"><strong>Initially, the import manager is empty.</strong></p>
<pre class="prettyprint lang-spec linenums">
subject.empty should be true</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Adding_elements">Adding elements</h3>
<ul><li><p id="After_adding_an_element_the_import_manager_is_not_empty_any_more" class="example notrun"><strong>After adding an element, the import manager is not empty any more.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Baz {
    }
  }
''')
val namespaceFooBar = model.allNamespaces.head as NamespaceDeclaration
var baz = namespaceFooBar.elements.head as Entity

subject.add(baz)
subject.empty should be false
subject.imports.size should be 1</pre>
</li><li><p id="Adding_the_same_element_multiple_times_only_yields_one_import" class="example notrun"><strong>Adding the same element multiple times only yields one import</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Baz {
    }
  }
''')
val namespaceFooBar = model.allNamespaces.head as NamespaceDeclaration
var baz = namespaceFooBar.elements.head as Entity

subject.add(baz)
subject.add(baz)
subject.empty should be false
subject.imports.size should be 1</pre>
</li><li><p id="Adding_two_different_elements_yields_two_imports" class="example notrun"><strong>Adding two different elements yields two imports</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Baz {
    }
    entity Boo {
    }
  }
''')
val namespaceFooBar = model.allNamespaces.head as NamespaceDeclaration
var baz = namespaceFooBar.elements.filter(typeof(Entity)).findFirst[name == &quot;Baz&quot;]
var boo= namespaceFooBar.elements.filter(typeof(Entity)).findFirst[name == &quot;Boo&quot;]

subject.add(baz)
subject.add(boo)
subject.imports.size should be 2</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Types">Types</h3>
<ul><li><p id="Primitive_types_must_not_be_imported" class="example notrun"><strong>Primitive types must not be imported.</strong></p>
<p>Primitive types are types that are built in to the host language, such as <code>int</code> or <code>long</code> in Java.</p><p>We do not want to import them, as this</p>
<ul>
  <li>unneccesary and</li>
  <li>illegal in most cases.</li>
</ul>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Foo
  datatype Zap
  platform FooBar {
    typemapping Foo -&gt; Foo (foo.base)
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.add(zapType)
subject.empty should be true</pre>
</li></ul>
<h3 class="exampleGroup pending"  id="Type_Mapping">Type Mapping</h3>
<p>Types can be mapped. This is needed in order to be able to use a common type system in the DSL while being able to use platform-specific types in the code generators for the individual platform.</p>
<h3 class="exampleGroup notrun"  id="Serialization">Serialization</h3>
<p>Sometime we need to add a type to the import manager and use the type name at the same time. This process is called <em>serialization</em>.</p>
<ul><li><p id="Serializing_a_type_will_return_its_possible_mapped_simple_name" class="example notrun"><strong>Serializing a type will return its [possible mapped] simple name</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Foo
  datatype Bar
  datatype Zap
  platform FooBar {
    typemapping Foo -&gt; Foo (foo.base)
    typemapping Bar -&gt; Bar (foo.baz)
    typemapping Zap -&gt; zap
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.serialize(zapType) should be 'zap'

val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
subject.serialize(barType) should be 'Bar'

val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
subject.serialize(fooType) should be 'Foo'</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Scope">Scope</h3>
<ul><li><p id="" class="example notrun"><strong></strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Foo {}
    entity Bar {}
  }
''')

val ns = model.elements.head as NamespaceDeclaration
val foo = ns.elements.filter(typeof(Entity)).findFirst[name == 'Foo']
val importManager = importManagerFactory.create(foo);

val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
importManager.serialize(bar) should be 'Bar'
importManager.empty should be true</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Well_known_classes">Well-known classes</h3>
<p>Well-known classes are classes that are part of the runtime and do not need to be imported, or that are part of the runtime and need to be imported using a specific, predefined import.</p>
<ul><li><p id="Classes_from_well_known_packages_are_not_imported" class="example notrun"><strong>Classes from well-known packages are not imported</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Foo
  datatype Bar
  platform FooBar {
    typemapping Foo -&gt; Foo (foo.base)
    typemapping Bar -&gt; Bar (foo.baz)
  }
''')

val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
subject.add(fooType)
subject.empty should be true</pre>
</li><li><p id="Classes_from_non_well_known_packages_should_be_imported" class="example notrun"><strong>Classes from non-well-known packages should be imported</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  datatype Foo
  datatype Bar
  platform FooBar {
    typemapping Foo -&gt; Foo (foo.base)
    typemapping Bar -&gt; Bar (foo.baz)
  }
''')

val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
subject.add(barType)
subject.empty should be false</pre>
</li></ul>
<h3 class="exampleGroup notrun"  id="Multiplicity">Multiplicity</h3>
<ul><li><p id="If_an_attribute_has_a_cardinality_of_1_the_regular_type_will_be_returned_when_serializing" class="example notrun"><strong>If an attribute has a cardinality of 1, the regular type will be returned when serializing</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Foo {}
    entity Baz {}
    entity Bar {
      Baz baz
      Foo[] foos
      Bar[] bars
    }
  }
''')

val ns = model.elements.head as NamespaceDeclaration

val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
val baz = bar.attributes.findFirst[name == 'baz']

val importManager = importManagerFactory.create(bar);

importManager.serialize(baz.type, baz.many) should be 'Baz'
importManager.imports.size should be 0</pre>
</li><li><p id="If_an_attribute_is_a_collection_a_typed_collection_will_be_returned_and_a_collection_type_will_be_imported" class="example notrun"><strong>If an attribute is a collection, a typed collection will be returned and a collection type will be imported.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Foo {}
    entity Bar {
      Foo[] foos
    }
  }
''')

val ns = model.elements.head as NamespaceDeclaration

val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
val foos = bar.attributes.findFirst[name == 'foos']

val importManager = importManagerFactory.create(bar);

importManager.serialize(foos.type, foos.many) should be 'foo.util.List&lt;Foo&gt;'
importManager.imports.head should be 'foo.util.List'
importManager.imports.size should be 1</pre>
</li><li><p id="If_multiple_attributes_are_collection_types_the_basic_list_type_must_only_be_imported_once" class="example notrun"><strong>If multiple attributes are collection types, the basic list type must only be imported once.</strong></p>
<pre class="prettyprint lang-spec linenums">
val model = parseHelper.parse('''
  namespace foo.bar {
    entity Foo {}
    entity Bar {
      Foo[] foos
      Bar[] bars
    }
  }
''')

val ns = model.elements.head as NamespaceDeclaration

val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
val foos = bar.attributes.findFirst[name == 'foos']
val bars = bar.attributes.findFirst[name == 'bars']

val importManager = importManagerFactory.create(bar);

importManager.serialize(foos.type, foos.many) should be 'foo.util.List&lt;Foo&gt;'
importManager.serialize(bars.type, bars.many) should be 'foo.util.List&lt;Bar&gt;'
importManager.imports.head should be 'foo.util.List'
importManager.imports.size should be 1</pre>
</li></ul>
							</div>
						    <div class="tab-pane" id="source">
						    	<h3>ImportManager.spec</h3>
						    	<p>
<pre class="prettyprint lang-spec linenums">
package org.applause.lang.base.importmanager.namespacebased

import org.applause.lang.base.ImportManager
import org.jnario.runner.CreateWith
import com.google.inject.Inject
import org.eclipse.xtext.junit4.util.ParseHelper
import org.applause.lang.applauseDsl.Model
import org.applause.lang.applauseDsl.Entity
import org.applause.lang.applauseDsl.NamespaceDeclaration
import org.applause.lang.applauseDsl.DataType
import org.applause.lang.base.ImportManagerFactory

@CreateWith(typeof(NamespaceBasedSpecCreator))
describe ImportManager {
  
  @Inject ParseHelper&lt;Model&gt; parseHelper
  
  def allNamespaces(Model model) {
    model.eAllContents.filter(typeof(NamespaceDeclaration))
  }
  
  context &quot;Initialization&quot; {
    fact &quot;Initially, the import manager is empty.&quot; {
      subject.empty should be true 
    }
  }
  
  context &quot;Adding elements&quot; {
    fact &quot;After adding an element, the import manager is not empty any more.&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Baz {
          }
        }
      ''')
      val namespaceFooBar = model.allNamespaces.head as NamespaceDeclaration
      var baz = namespaceFooBar.elements.head as Entity
      
      subject.add(baz)
      subject.empty should be false
      subject.imports.size should be 1
    }
    
    fact &quot;Adding the same element multiple times only yields one import&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Baz {
          }
        }
      ''')
      val namespaceFooBar = model.allNamespaces.head as NamespaceDeclaration
      var baz = namespaceFooBar.elements.head as Entity
      
      subject.add(baz)
      subject.add(baz)
      subject.empty should be false
      subject.imports.size should be 1
    }
    
    fact &quot;Adding two different elements yields two imports&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Baz {
          }
          entity Boo {
          }
        }
      ''')
      val namespaceFooBar = model.allNamespaces.head as NamespaceDeclaration
      var baz = namespaceFooBar.elements.filter(typeof(Entity)).findFirst[name == &quot;Baz&quot;]
      var boo= namespaceFooBar.elements.filter(typeof(Entity)).findFirst[name == &quot;Boo&quot;]
      
      subject.add(baz)
      subject.add(boo)
      subject.imports.size should be 2
    }
    
  }
  
  context &quot;Types&quot; {
    /**
     * Primitive types are types that are built in to the host language, such as `int` or `long` 
     * in Java. 
     * 
     * We do not want to import them, as this
     *  
     * - unneccesary and 
     * - illegal in most cases.
     * 
     */
    fact &quot;Primitive types must not be imported.&quot; {
      val model = parseHelper.parse('''
        datatype Foo
        datatype Zap
        platform FooBar {
          typemapping Foo -&gt; Foo (foo.base)
          typemapping Zap -&gt; zap primitive
        }
      ''')
      
      val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
      subject.add(zapType)
      subject.empty should be true
    }
      
  }
  
  /**
   * Types can be mapped. This is needed in order to be able to use a common type system in the DSL
   * while being able to use platform-specific types in the code generators for the individual platform.
   */
  context &quot;Type Mapping&quot; {
  }

  /**
   * Sometime we need to add a type to the import manager and use the type name at the same time. 
   * This process is called _serialization_.
   */
  context &quot;Serialization&quot; {
    
    fact &quot;Serializing a type will return its (possible mapped) simple name&quot; {
      val model = parseHelper.parse('''
        datatype Foo
        datatype Bar
        datatype Zap
        platform FooBar {
          typemapping Foo -&gt; Foo (foo.base)
          typemapping Bar -&gt; Bar (foo.baz)
          typemapping Zap -&gt; zap
        }
      ''')
      
      val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
      subject.serialize(zapType) should be 'zap'
  
      val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
      subject.serialize(barType) should be 'Bar'
  
      val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
      subject.serialize(fooType) should be 'Foo'
    }
  } 

  context &quot;Scope&quot; {
    
    @Inject ImportManagerFactory importManagerFactory    
    
    fact &quot;&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Foo {}
          entity Bar {}
        }
      ''')
      
      val ns = model.elements.head as NamespaceDeclaration
      val foo = ns.elements.filter(typeof(Entity)).findFirst[name == 'Foo']
      val importManager = importManagerFactory.create(foo);
      
      val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
      importManager.serialize(bar) should be 'Bar'
      importManager.empty should be true      
    }
  }
  
  /**
   * Well-known classes are classes that are part of the runtime and do not need to be imported, or that 
   * are part of the runtime and need to be imported using a specific, predefined import.
   */
  context &quot;Well-known classes&quot; {
    
    fact &quot;Classes from well-known packages are not imported&quot; {
      val model = parseHelper.parse('''
        datatype Foo
        datatype Bar
        platform FooBar {
          typemapping Foo -&gt; Foo (foo.base)
          typemapping Bar -&gt; Bar (foo.baz)
        }
      ''')
      
      val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
      subject.add(fooType)
      subject.empty should be true
    }    
    
    fact &quot;Classes from non-well-known packages should be imported&quot; {
      val model = parseHelper.parse('''
        datatype Foo
        datatype Bar
        platform FooBar {
          typemapping Foo -&gt; Foo (foo.base)
          typemapping Bar -&gt; Bar (foo.baz)
        }
      ''')
      
      val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
      subject.add(barType)
      subject.empty should be false
    }    
  }
  
  context &quot;Multiplicity&quot; {
    
    @Inject ImportManagerFactory importManagerFactory    

    fact &quot;If an attribute has a cardinality of 1, the regular type will be returned when serializing&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Foo {}
          entity Baz {}
          entity Bar {
            Baz baz
            Foo[] foos
            Bar[] bars
          }
        }
      ''')
      
      val ns = model.elements.head as NamespaceDeclaration
      
      val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
      val baz = bar.attributes.findFirst[name == 'baz']
      
      val importManager = importManagerFactory.create(bar);
      
      importManager.serialize(baz.type, baz.many) should be 'Baz'
      importManager.imports.size should be 0
    }
    
    fact &quot;If an attribute is a collection, a typed collection will be returned and a collection type will be imported.&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Foo {}
          entity Bar {
            Foo[] foos
          }
        }
      ''')
      
      val ns = model.elements.head as NamespaceDeclaration
      
      val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
      val foos = bar.attributes.findFirst[name == 'foos']
      
      val importManager = importManagerFactory.create(bar);
      
      importManager.serialize(foos.type, foos.many) should be 'foo.util.List&lt;Foo&gt;'
      importManager.imports.head should be 'foo.util.List'
      importManager.imports.size should be 1      
    }
    
    fact &quot;If multiple attributes are collection types, the basic list type must only be imported once.&quot; {
      val model = parseHelper.parse('''
        namespace foo.bar {
          entity Foo {}
          entity Bar {
            Foo[] foos
            Bar[] bars
          }
        }
      ''')
      
      val ns = model.elements.head as NamespaceDeclaration
      
      val bar = ns.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
      val foos = bar.attributes.findFirst[name == 'foos']
      val bars = bar.attributes.findFirst[name == 'bars']
      
      val importManager = importManagerFactory.create(bar);
      
      importManager.serialize(foos.type, foos.many) should be 'foo.util.List&lt;Foo&gt;'
      importManager.serialize(bars.type, bars.many) should be 'foo.util.List&lt;Bar&gt;'
      importManager.imports.head should be 'foo.util.List'
      importManager.imports.size should be 1      
    }
  }
  

}
</pre>
						    </p></div>
						  </div>
					</div> 
				</div> <!-- /row -->
			</div> <!-- /content -->
		</div> <!-- /tabbable -->
		<footer>
			<p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>
	</div> <!-- /container -->

</body>
</html>
