<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>ImportManager</title>
<meta name="description" content="">
<meta name="author" content="Jnario">

<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Le styles -->
<link rel="stylesheet" href="../../../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../../../css/custom.css">
<link rel="stylesheet" href="../../../../../../css/prettify.css">
<script type="text/javascript" src="../../../../../../js/prettify.js"></script>
<script type="text/javascript" src="../../../../../../js/lang-jnario.js"></script>
</head>

<body onload="prettyPrint()">
	<div class="container">
		<div class="content">
			<div class="page-header">
				<h1>ImportManager</h1>
			</div>
			<div class="row">
				<div class="span12">
<p>The class based import manager is intended to be used with languages like <strong>Objective-C</strong> that do not support namespaces or packages.</p>
<h2 id="Initialization">Initialization</h2>
<ul><li><p id="Initially_the_import_manager_is_empty"><strong>Initially, the import manager is empty.</strong></p>
<pre class="prettyprint lang-spec">
subject.empty should be true</pre>
</li></ul>
<h2 id="Adding_elements">Adding elements</h2>
<ul><li><p id="After_adding_an_element_the_import_manager_is_not_empty_any_more"><strong>After adding an element, the import manager is not empty any more.</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  entity Baz {
  }
''')
var baz = model.elements.head as Entity

subject.add(baz)
subject.empty should be false
subject.imports.size should be 1</pre>
</li><li><p id="Adding_the_same_element_multiple_times_only_yields_one_import"><strong>Adding the same element multiple times only yields one import</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  entity Baz {
  }
''')
var baz = model.elements.head as Entity

subject.add(baz)
subject.add(baz)
subject.empty should be false
subject.imports.size should be 1</pre>
</li><li><p id="Adding_two_different_elements_yields_two_imports"><strong>Adding two different elements yields two imports</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  entity Baz {
  }
  entity Boo {
  }
''')
var baz = model.elements.filter(typeof(Entity)).findFirst[name == &quot;Baz&quot;]
var boo= model.elements.filter(typeof(Entity)).findFirst[name == &quot;Boo&quot;]

subject.add(baz)
subject.add(boo)
subject.imports.size should be 2</pre>
</li></ul>
<h2 id="Types">Types</h2>
<ul><li><p id="Primitive_types_must_not_be_imported"><strong>Primitive types must not be imported.</strong></p>
<p>Primitive types are types that are built in to the host language, such as <code>int</code> or <code>long</code> in Java.</p><p>We do not want to import them, as this</p>
<ul>
  <li>unneccesary and</li>
  <li>illegal in most cases.</li>
</ul>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.add(zapType)
subject.empty should be true</pre>
</li></ul>
<h2 id="Type_Mapping">Type Mapping</h2>
<p>Types can be mapped. This is needed in order to be able to use a common type system in the DSL while being able to use platform-specific types in the code generators for the individual platform.</p>
<ul><li><p id="Adding_a_primitive_type_must_not_yield_an_import_even_if_the_type_is_mapped"><strong>Adding a primitive type must not yield an import, even if the type is mapped.</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.add(zapType)
subject.empty should be true</pre>
</li><li><p id="However_serializing_a_primitive_type_must_yield_the_mapped_name_and_NO_import"><strong>However, serializing a primitive type must yield the mapped name [and NO import].</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.serialize(zapType) should be 'zap'
subject.empty should be true</pre>
</li><li><p id="Mapping_a_regular_type_should_yield_the_mapped_type_name_as_an_import"><strong>Mapping a regular type should yield the mapped type name as an import.</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Bar
  platform ClassBased {
    typemapping Bar -&gt; BarClass
  }
''')

val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
subject.add(barType)
subject.imports.head should be 'BarClass'</pre>
</li></ul>
<h2 id="Serialization">Serialization</h2>
<p>Sometime we need to add a type to the import manager and use the type name at the same time. This process is called <em>serialization</em>.</p>
<ul><li><p id="Serializing_a_primitive_type_yields_its_mapped_name"><strong>Serializing a primitive type yields its mapped name</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Zap
  platform ClassBased {
    typemapping Zap -&gt; zap primitive
  }
''')

val zapType = model.elements.filter(typeof(DataType)).findFirst[name == 'Zap']
subject.serialize(zapType) should be 'zap'</pre>
</li><li><p id="Serializing_a_mapped_type_yields_its_mapped_name"><strong>Serializing a mapped type yields its mapped name</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Foo
  platform ClassBased {
    typemapping Foo -&gt; FooClass
  }
''')

val fooType = model.elements.filter(typeof(DataType)).findFirst[name == 'Foo']
subject.serialize(fooType) should be 'FooClass'</pre>
</li><li><p id="Serializing_an_unmapped_type_yields_its_regular_name"><strong>Serializing an unmapped type yields its regular name</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Bar
''')

val barType = model.elements.filter(typeof(DataType)).findFirst[name == 'Bar']
subject.serialize(barType) should be 'Bar'</pre>
</li></ul>
<h2 id="Scope">Scope</h2>
<ul><li><p id="A_type_must_not_import_itself_Only_external_types_need_to_be_imported"><strong>A type must not import itself. Only external types need to be imported.</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  entity Foo { }
  entity Bar extends Foo {}
''')
val foo = model.elements.filter(typeof(Entity)).findFirst[name == 'Foo']
val bar = model.elements.filter(typeof(Entity)).findFirst[name == 'Bar']

val importManager = importManagerFactory.create(bar)

importManager.add(bar)
importManager.imports.size should be 0
importManager.serialize(bar) should be 'Bar'

importManager.serialize(foo) should be 'Foo'
importManager.imports.size should be 1</pre>
</li></ul>
<h2 id="Well_known_classes">Well-known classes</h2>
<p>Well-known classes are classes that are part of the runtime and do not need to be imported, or that are part of the runtime and need to be imported using a specific, predefined import.</p>
<ul><li><p id="Well_known_classes_can_register_a_specific_import"><strong>Well-known classes can register a specific import</strong></p>
<p>Well-known classes can register a specific import. This makes sense for languages that support having more than one class inside a particular source file. In this case, the name of the import cannot be derived directly from the name of the class to be imported. Instead, we need to register an import for each of those classes.</p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Hubba
  datatype Chuppa
  platform ClassBased {
    typemapping Hubba -&gt; HubbaClass
    typemapping Chuppa -&gt; ChuppaClass
  }
''')
val hubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Hubba']
subject.serialize(hubba) should be 'HubbaClass'
subject.imports.head should be 'BaseClasses/ChewingGums'</pre>
</li><li><p id="Several_well_known_classes_can_register_the_same_specific_import"><strong>Several well-known classes can register the same specific import</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Hubba
  datatype Chuppa
  datatype Bubba
  platform ClassBased {
    typemapping Hubba -&gt; HubbaClass
    typemapping Chuppa -&gt; ChuppaClass
    typemapping Bubba -&gt; BubbaClass
  }
''')
val hubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Hubba']
val bubba = model.elements.filter(typeof(DataType)).findFirst[name == 'Bubba']
subject.serialize(hubba) should be 'HubbaClass'
subject.imports.head should be 'BaseClasses/ChewingGums'
subject.serialize(bubba) should be 'BubbaClass'
subject.imports.head should be 'BaseClasses/ChewingGums'</pre>
</li><li><p id="Well_known_classes_must_only_be_imported_if_they_register_an_import"><strong>Well-known classes must only be imported if they register an import</strong></p>
<pre class="prettyprint lang-spec">
val model = parseHelper.parse('''
  datatype Hubba
  datatype Chuppa
  platform ClassBased {
    typemapping Hubba -&gt; HubbaClass
    typemapping Chuppa -&gt; ChuppaClass
  }
  entity Bar {
    Hubba bubba
    Chuppa chups
  }
''')

val bar = model.elements.filter(typeof(Entity)).findFirst[name == 'Bar']
val importManager = importManagerFactory.create(bar)

val chups = bar.attributes.findFirst[name == 'chups']
importManager.serialize(chups.type) should be 'ChuppaClass'
importManager.imports.size should be 0

val hubba = bar.attributes.findFirst[name == 'bubba']
importManager.serialize(hubba.type) should be 'HubbaClass'
importManager.imports.size should be 1</pre>
</li></ul>
				</div>
			</div>
		</div> <!-- /content -->
		<footer>
			<p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>

	</div>
	<!-- /container -->

</body>
</html>
